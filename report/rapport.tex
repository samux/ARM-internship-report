\documentclass[pdftex,10pt,a4paper]{report}

\usepackage[pdftex]{graphicx}
\usepackage{enumitem}
\usepackage{fmtcount}
\usepackage{multirow}
\usepackage[margin=0.8in]{geometry}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{caption}
\usepackage{array}
\usepackage{subfigure}
\usepackage{comment}

\newenvironment{packed_enum}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\newenvironment{packed_item}{
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}


\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	rulecolor=,
	language=C++,
        basicstyle=\scriptsize,
        upquote=true,
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
}


\renewcommand{\thefootnote}{\arabic{footnote}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\input{./title.tex}
\tableofcontents
\chapter{ARM and Mbed}
\section{ARM}
ARM Holdings plc is a British multinational semiconductor and software company. The headquarter is based in Cambridge. This company is well-known in the processor field, although it also designs, licenses and sells software development tools under the RealView and KEIL brands, systems and platforms, system-on-a-chip infrastructure and software. 
\\

Advanced RISC Machines Ltd (now ARM Ltd) was founded in November 1990. It is the result of a joint venture between Acorn Computers, Apple Computer (now Apple Inc.) and VLSI Technology (now NXP semiconductor). The purpose of this joint venture was to develop a RISC chip originally developped by Acorn Computer involved in an Apple project. ARM got bigger little by little by acquiring companies like Micrologic Solutions, a software consulting company based in Cambridge 1999. In 2000, ARM acquired Allant Software, Infinite Designs in Sheffield (UK) and EuroMips in Sophia Antipolis (France). Then, in 2001, it acquired a team specialized in hardware and software debugging based in Blackburn (UK). In 2005, ARM acquired Keil Software, a leader in the software development tools for microcontrollers. More recently, ARM joined with Texas Instrument, Samsung, IBM, ST-Ericsson and Freescale Semiconductor in forming an open source engineering company named Linaro. Linaro produces for example ARM tools or linux kernels for ARM based system-on-chips. Today, ARM has offices and design centres all over the world, including UK, Germany, France, Israel, Sweden, Norway, Slovenia, USA, China, South Korea, Japan, Taiwan and India. 
\\

Nowadays, ARM processors are widely used in mobile phones, tablets, personal digital assistants, GPS, digital cameras and digital televions. The main reason of this success is their low electric power consumption; making them suitable for embedded systems. Even if ARM products are widely used, the company doesn't manufacture its own CPUs. The company licenses its technology as Intellectual Property (IP). Companies like Intel, Texas Intrument or Nvidia are making processors based on ARM's IP.



\section{Mbed}
In wish to pursue new areas of expertise, ARM founded Mbed in 2009. Mbeds core area is development of prototyping boards (called mbed) based on ARM processors (Cortex M0 and Cortex M3). The purpose is to make available a simple and easy to set-up prototyping solution using 32-bits processors. Mbeds boards have been designed for quick experimentation. Users can try something and see if it is doable in a very easily and quickly manner.

\subsection{Mbed boards: LPC1768 and LPC11U24}
For the moment, two boards have been developped. The first one is based on the LPC1768 microcontroller from NXP which uses a Cortex m3. More recently, a new board based on a LPC11U24 (Cortex m0) was born. This last mbed has been particularly designed to prototype USB devices or battery powered applications. 

\begin{figure}[h!]
\centering
\includegraphics[width=0.3\textwidth]{./lpc1768.png}
\caption{mbed board: lpc1768 (cortex m3)}
\label{mbed_board: lpc1768 (Cortex m3)}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=0.3\textwidth]{./lpc11U24.png}
\caption{mbed board: lpc11U24 (cortex m0)}
\label{mbed_board: lpc11U24 (Cortex m0)}
\end{figure}


\subsection{The online compiler}
The two main keywords of Mbed are "simple" and "cloud computing". Users indeed use an online compiler to develop their program in C++. They compile online and transfer the binary received into the mbed, which is connected to a computer over a USB cable and detected as a mass storage device. They just have to press the reset button to see their program running.
\\

As explained before, users have a complete online IDE totally independant of the underlying operating system. 
This IDE has a lot of very interesting features:
\begin{packed_item}
	\item Code editing with syntax highlighting
	\item Multiple programs
	\item Import programs from online catalogue of published programs
	\item Import programs from zip file
	\item Full output of compile-time messages
	\item Multiple target support
	\item Publish your code directly from the compiler
	\item Export your programs as a .zip file
	\item Build information including graphical display of code size and RAM usage
	\item Code formatter
	\item Import and update of libraries from SVN
	\item Version control: you can commit, revert, update, merge your programs
\end{packed_item}

\subsection{Mbed libraries}
In addition to the online compiler, almost all drivers have been implemented. Users just have to instanciate an object such as SPI, I2C,... to have access to a great API which abstract all the low-level layer. \\


\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{./libraries.png}
\caption{mbed libraries}
\label{mbed libraries}
\end{figure}


\subsection{Mbed website: \textit{http://mbed.org/}}
To finish this tour of the mbed environment, users can find an active website. First, users have access to a forum. They have also access to a handbook where there is a lot of documentation and examples concerning mbed libraries, the hardware part of the mbed,... But the most important feature of this website is for me the central cookbook. This cookbook is a great source of example coming from other mbed users. You can almost find for instance a lot of libraries to use popular sensors like accelerometers, pressure sensors,... Each user is free to contribute to this part of the website by doing articles explaining their project. 

\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{./cookbook.png}
\caption{mbed cookbook}
\label{mbed cookbook}
\end{figure}


\chapter{Internet Of Things: HTML5 on embedded systems}
Nowadays, an increasing number of devices are connected to the Internet. These devices include not only personal computers, but also mobile phones and digital televisions, ect.
Cisco predicts in an interview from the BBC that the number of internet connected devices is set to explode in the next four years to over 15 billion - twice the world's population by 2015. And Cisco is not the only one company to predict a such boom. VMware's CEO Paul Maritz said during a speech at the annual VMworld conference in Las Vegas in August 2011 that:

\begin{quote} "Three years ago over 95 percent of the devices connected to the Internet were personal computers. Three years from now that number will probably be less than 20 percent. More than 80 percent of the devices connected to the Internet will not be Windows-based personal computers." \\
\end{quote}

Thus, working on the connection of different sensors to the Internet is becoming more and more crucial. I will describe in this chapter two projects concerning the Internet of Things: real-time data streaming from sensors and Remote Procedure Call mechanism. Both of these projects use a new feature of HTML5: a Webscocket communication.


\begin{figure}[h!]
		\centering
		\includegraphics[width=0.4\textwidth]{./logo_ws.jpg}
		\caption{HTML5 on embedded systems}
		\label{HTML5 on embedded systems}
\end{figure}

\section{Websockets}
\subsection{Introduction}
The WebSocket specification is a new feature of HTML5. It defines a full-duplex single socket connection over which messages can be sent between client and server. The WebSocket standard simplifies much of the complexity around bi-directional web communication and connection management. Furthermore, it reduces polling and unnecessary network throughput overhead.

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\textwidth]{./ws_poll.jpg}
		\caption{Reduction of polling and overhead by Websocket \textit(Image coutesy of Kaazing)}
		\label{Reduction of polling and overhead by Websocket}
\end{figure}

This figure shows the reduction in latency. Once the connection is established, messages can flow from the server to the browser. As the connection remains open, there is no need to send another request to the server.

\subsection{Websocket protocol}

To establish a WebSocket connection, the client and server upgrade from the HTTP protocol to the WebSocket protocol during their initial handshake.

The handshake from the client looks as follows: \\

\fbox{\begin{minipage}{1.0\textwidth} \small
	GET /ws HTTP/1.1 \\
	Host: example.org \\
  Connection: Upgrade \\
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== \\
  Upgrade: WebSocket \\
  Origin: http://example.org \\
  Sec-WebSocket-Version: 13 \\
  \end{minipage}
}
\\ \\
The handshake from the server looks as follows: \\

\fbox{\begin{minipage}{1.0\textwidth} \small
        HTTP/1.1 101 Switching Protocols \\
        Upgrade: websocket \\
        Connection: Upgrade \\
        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= \\
        \end{minipage} 
        }
\\ \\
Once the Websocket connection is established, data can be exchanged between client and server. Data can either be text frame encoded as UTF-8 or binary data.

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.6\textwidth]{./frame_ws.jpg}
		\caption{Websocket data framing}
		\label{Websocket data framing}
\end{figure}

\begin{packed_item}
	\item FIN: Indicates that this is the final fragment in a message.
	\item RSVx: reserved (0)
	\item Opcode: meaning of the payload:
		\begin{packed_item}
			\item 0x0: continuation frame
			\item 0x1: text frame (the payload is text data encoded as UTF-8)
			\item 0x2: binary frame (the payload is binary data)
			\item 0x8: connection close
			\item 0x9: ping (can be used as keep-alive mechanism)
			\item 0xa: pong (can be used as keep-alive mechanism)
		\end{packed_item}
	\item Mask: defines whether the payload data is masked or not
	\item payload length (in bytes):
		\begin{itemize}
			\item 0 - 125: payload length
			\item 126: the following 2 bytes represent the payload length
			\item 127: the following 8 bytes represent the payload length
		\end{itemize}
	\item Masking-key: used to unmask the payload
	\item Payload data: data
\end{packed_item}


\subsection{Architecture of a Websocket communication}
A websocket communication involves several clients connected to the same websocket server. All messages from browsers are sent to the server. The server manages all messages. It can decide to send a message received from a client to another client, to broadcast all messages received to all clients connected,...


\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\textwidth]{./ws.jpg}
		\caption{Example of websocket communication}
		\label{Example of websocket communication}
\end{figure}

For instance, let's say that there is an existing websocket server: example.com which is listening on port 80. A client can open a connection, receive and send messages to this server with this few lines of javascript:

\begin{center}
\begin{lstlisting}[label=Device descriptor,caption=Device Descriptor]
var ws = new WebSocket("ws://example.com");
ws.onopen = function(evt) { 
   alert("Connection open"); 
   ws.send("Hello")}; 
};
ws.onmessage = function(evt) { 
   alert( "Message received: " + evt.data); 
}; 
ws.onclose = function(evt) { 
   alert("Connection closed."); 
};
\end{lstlisting}
\end{center}


\subsection{The mbed websocket library}
A websocket client library has been developped in order to exchange data between an mbed and a server over a websocket communication. This library can either be used over an ethernet connection or a wifi connection using a roving networks wifly module. This library uses existing libraries such as the wifi module library or the TCP socket library, part of the TCP/IP stack (port of lwIP for mbed). For instance, the method which connects an mbed to a websocket server over wifly is:


\begin{center}
\begin{lstlisting}[label=Connection to a websocket server,caption=Connection to a websocket server]
// open a socket on a specific port
sprintf(cmd, "open %s %s\r\n", ip_domain.c_str(), port.c_str());
wifi->send(cmd, "OPEN");

//send websocket HTTP header
sprintf(cmd, "GET /%s HTTP/1.1\r\n", path.c_str());
wifi->send(cmd);
sprintf(cmd, "Host: %s:%s\r\n", ip_domain.c_str(), port.c_str());
wifi->send(cmd);
wifi->send("Upgrade: websocket\r\n");
wifi->send("Connection: Upgrade\r\n");
wifi->send("Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n");
sprintf(cmd, "Origin: http:%s:%s\r\n", ip_domain.c_str(), port.c_str());
wifi->send(cmd);
if (!wifi->send("Sec-WebSocket-Version: 13", "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="))
   return false;

\end{lstlisting}
\end{center}

\newpage

\section{Real-Time Data Streaming from sensors}
Mbed wanted to demonstrate that it was possible to access sensor data all over the world using an mbed board. For this, two prototypes boards has been developed with different sensors:

\begin{packed_item}
	\item accelerometer board with a three axis accelerometer
	\item environmental board with:
		\begin{packed_item}
			\item light sensor
			\item pressure sensor
			\item microphone
		\end{packed_item}
\end {packed_item}

The idea behind this project is that the sensor data has to be available from everywhere as quick as possible. That's why we want to involve smartphones connected to the Internet over 3G for instance. To achieve this, we used QR codes to speed up the whole process. The steps to access data for a user are:

\begin{packed_item}
	\item Place the object (mbed and sensors) where desired
	\item Scan the QR code on the sensor with a smartphone to see its data displayed
	\item Click the 'add' button to add the sensor to your dashboard (central webpage showing all sensors connected)
\end{packed_item}


\subsection{Architecture: mbed boards, websocket server, browsers}
We can distinguish three different parts:
\begin{packed_item}
	\item a websocket server
	\item mbed boards which are connected to this websocket server
	\item browsers which are connected to the same server (running on laptops or smartphones)
\end{packed_item}

All mbed boards send messages in JSON format to the websocket server containing sensors data. The websocket server will broadcast to all client connected all messages received. So all browsers connected to this server are able to receive data from sensors.

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.8\textwidth]{./ws_arch.png}
		\caption{Architecture real-time data streaming}
		\label{Architecture real-time data streaming}
\end{figure}


\subsection{Websocket server}
The websocket server which has been developed uses Tornado framework. This framework is written in Python. It's a non blocking web server. It uses epoll which permit to handle thousands of connections and so provides realtime features. Some interesting features are for instance:
\begin{packed_item}
	\item http server
	\item template language
	\item mySQL client wrapper
	\item websocket server
\end{packed_item}

\begin{lstlisting}[label=Open a websocket connection,caption=Open a websocket connection]
application = tornado.web.Application([
    (r'/ws/(.*)/(.*)', WSHandler),
], **settings)

if __name__ == "__main__":
    http_server = tornado.httpserver.HTTPServer(application)
    http_server.listen(443)
    tornado.ioloop.IOLoop.instance().start()
\end{lstlisting}

These few lines launch a http server associated with a handler (WSHandler) when an event occurs. All requests having a path matching the regular expression \textbf{/ws/*/*} will be redirected to  WSHandler. The first argument of the path represents a channel and the second one the connection mode. This means that to open a connection with this server, a client has to join the server at the address: 
\begin{center}
\textbf{ws://sockets.mbed.org/ws/\textless{}channel\textgreater{}/\textless{}mode\textgreater{}}
\end{center}

The WebSocket server is divided into channels. All clients can send and receive messages over a same channel according their connection mode.
There are 3 connection modes:

\begin{packed_item}
	\item write-only (wo): the client can write on a certain channel but cannot receive messages
	\item read-only (ro): the client can read messages on a certain channel but cannot write messages
	\item read-write (rw): the client can read and write messages over a channel
\end{packed_item}

When the server receives a message from a client in a certain channel which is not in 'ro' mode, it will broadcast the message to all clients connected to this channel which are in 'rw' or 'ro' mode. This mechanism is done in WShandler which inherits from tornado.websocket.WebSocketHandler. The websocket protocol is implemented in the base class. You can override three different events in WShandler: 

\begin{packed_item}
	\item a connection has been opened
	\item a message is received
	\item a connection has been closed
\end{packed_item}

\begin{lstlisting}[label=Broadcast messages received,caption=Broadcast messages received]
class WSHandler(tornado.websocket.WebSocketHandler):
    def open(self, chan, mode):
        self.channel = chan
        self.mode = mode
        if mode == 'rw' or mode == 'ro' or mode =='wo':
            if not subscribers.get(self.channel):
                subscribers[self.channel] = []
            subscribers[self.channel].append(self)	
            logging.warning("New Subscribers: chan %s, mode: %s"%(chan, mode))

    def on_message(self, message):
        for client in subscribers.get(self.channel, []):
        		if client.mode != 'wo':
	              client.write_message(message)
\end{lstlisting}



\subsection{Mbed boards}
\subsubsection{Hardware}
The hardware is very simple to setup as mbed is especially designed to prototype. The main parts are:
\begin{packed_item}
	\item one mbed
	\item a wifi module
	\item sensors
\end{packed_item}

To connect the mbed to the internet and access the websocket server, a wifi module has been chosen. I wanted a wifi module easy to use and easy to connect to the mbed. I chose a wifi module from roving networks which integrates a full TCP/IP stack. The communication between the mbed and the wifly module is established over a serial port. This module is integrated on a breakout board so that we just need wires to connect with the mbed. 

Concerning sensors, all are also very easy to use and to connect. The 3-axis accelerometer and the pressure sensor are connected to the mbed over SPI. Libraries has been developed by the mbed community to use these two previous sensors. The light sensor is connected over a GPIO as the microphone. 


\begin{figure}[h!]
		\centering
		\includegraphics[width=0.4\textwidth]{./env_board.png}
		\caption{Environmental board}
		\label{Environmental board}
\end{figure}


\subsubsection{Software}
The program running on the mbed has to :
\begin{packed_item}
	\item connect to a network
	\item connect to the websocket server
	\item in a loop:
		\begin{packed_item}
			\item read sensor data
			\item send them over websocket to the server
		\end{packed_item}
\end{packed_item}


\begin{center}
\begin{lstlisting}[label=Streaming data code example,caption=Streaming data code example]
// wifly instance to connect the wireless network
Wifly wifly(p9, p10, p30, "network", "password", true);

// Websocket instance to send sensor data to the websocket server: we use the channel "sensors" in write-only mode
Websocket ws("ws://sockets.mbed.org/ws/sensors/wo", &wifly);

int main() {
    char json_str[100];
    int press;
    double temp;
    int light;
    unsigned short mic;
    
    // join the wireless network
    wifly.join();
    		
    // connection to the websocket server
    ws.connect();
    		
    while (1) {
    	wait(0.1);

      //pressure
      press = scp1000.readPressure();

      //temperature
      temp = scp1000.readTemperature();

      //light
      light = light_pin.read_u16()/480;

      //microphone
      mic = readMicrophone();

			// format data in a JSON string and sent it
      sprintf(json_str, "{\"id\":\"wifly_env\",\"p\":\"%d\",\"t\":\"%d\",\"l\":\"%d\",\"m\":\"%d\"}", (int)press, (int)temp, (int)(140 - light), mic);
      ws.send(json_str);
   }
}
\end{lstlisting}
\end{center}



\subsection{Browsers}
To develop webpages running on a laptop in the case of the dashboard or running on a smartphone, I wanted to use another new HTML5 feature which is the canvas element. Javascript code can access this drawable region through a complete API. The canvas element can be for instance used to display realtime graphs or to build games and animations.
\\


There are two different webpages:
\begin{packed_item}
	\item smartphones webpage: displays only the graph of the corresponding QR code scanned. Two buttons can be used to add or remove a specific graph of the dashboard webpage.
	\item dashboard: displays all graphs added by users.
\end{packed_item}

\subsubsection{Realtime graphs}
I use Smoothie Charts which is a javascript library to stream data on a canvas element. Smoothie Charts is a small charting library designed for live streaming data. The idea is to display in realtime sensor data in a live chart refreshed everytime that we receive a new data.

\subsubsection{Websocket and JSON messages}
Several messages are exchanged between clients and server. 
\begin{packed_item}
	\item from mbed boards: 
		\begin{center}
				\{"id"="wifly\_acc", "ax"="x\_axis\_value", "ay"="y\_axis\_value", "az"="z\_axis\_value"\} \\
				\{"id"="wifly\_env", "l"="light\_value", "t"="temperature\_value", "p"="pressure\_value", "m"="microphone\_value"\}
		\end{center}
	\item from smartphones:
		\begin{center}
				\{"id"="acc\_add"\} \\
				\{"id"="env\_add"\} \\
				\{"id"="acc\_clean"\} \\
				\{"id"="env\_clean"\}
		\end{center}
		
\end{packed_item}

Messages sent by mbed boards contain sensor data. When a client will receive a such message, it will refresh a realtime graph showing the sensor data evolution. \\
Messages sent by smartphones control graphs on the dashboard webpage. For instance, if a user scans the QR code of the accelerometer board and press the add button, the message 
		\begin{center}
				\{"id"="acc\_add"\}
		\end{center}
will be sent. The dashboard will then display the corresponding graph. \\


The architecture of all webpages is quite simple:
\begin{packed_item}
	\item Connection to the websocket server
	\item When a message is received from sensors:
		\begin{packed_item}
			\item check the validity of the message
			\item update the corresponding graph (there is one graph per sensor board)
		\end{packed_item}
	\item When a message is received from smartphones:
		\begin{packed_item}
			\item check the validity of the message
			\item update the Document Object Model (DOM) using the jQuery javascript library
		\end{packed_item}
\end{packed_item}


\begin{center}
\begin{lstlisting}[label=Streaming data code example,caption=Streaming data code example]
		// Websocket instance connected on the same subnetwork as the mbed boards
    websocket = new WebSocket('ws://sockets.mbed.org/ws/sensors/rw');

    websocket.onmessage = function (evt) {
			var json_sensor = jQuery.parseJSON(evt.data.toString());
			if(json_sensor.id == "wifly_acc") 
			{
				acc_x.append(new Date().getTime(), json_sensor.ax);
				acc_y.append(new Date().getTime(), json_sensor.ay);
				acc_z.append(new Date().getTime(), json_sensor.az);

				refreshBall();
			}
			else if(json_sensor.id == "wifly_env") 
			{
				light.append(new Date().getTime(), json_sensor.l);
				temp.append(new Date().getTime(), json_sensor.t);
				press.append(new Date().getTime(), json_sensor.p / 1000);
				mic.append(new Date().getTime(), json_sensor.m);

				refreshEnv();
			}
			else
				manipulateDOM(json_sensor.id);
		};
	\end{lstlisting}
\end{center}

As expected, when a websocket message is received the corresponding graph is updated. If the "id" field on the message is different from wifly\_acc or wifly\_env, it's probably a message coming from a smartphone indicating to the dashboard to display or not a specific graph. 

\subsubsection{Results}

\begin{figure}[htp]
  \centering
  \subfigure[Dashboard webpage]{\label{fig:edge-a}\includegraphics[scale=0.75]{./dashboard.jpg}}                
  \subfigure[Smartphone webpage]{\label{fig:contour-b}\includegraphics[scale=0.75]{./dashboard.jpg}} \\
  \caption{Webpages which access sensor data}
  \label{fig:contour}
\end{figure}

On the dashboard, we can see that the environmental board has been added:
\begin{packed_item}
	\item realtime graph available (10 Hz): light, pressure, temperature and microphone data
	\item more information are available on the right: other representations of sensor data
\end{packed_item}

On the smartphone webpage, we can observe the live graph containing sensor data. On this webpage, we can manage the dashboard with the "add" and "clear" buttons.

\subsection{Conclusion}
This first project shows the powerful of the new HTML5 feature: websockets. I am able to stream sensor data and display them in realtime graphs. Therefore, these data are accessible all over the world.


After the Internet of Things project, mbed wanted to develop a Remote Procedure Call mechanism between several mbeds over a websocket communication.













\newpage

\section{Remote Procedure Call over Websockets}
After the Internet of Things project which shows the power of HTML5 in embedded systems, mbed wanted to use websockets to design a RPC (Remote Procedure Call) mechanism. The idea is to enable users to call a specific method on a specific mbed. Both of these mbed are connected to the Internet.

\subsection{Architecture: mbed boards, websocket server}

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\textwidth]{./rpc-1.jpg}
		\caption{RPC architecture}
		\label{RPC architecture}
\end{figure}


On the previous diagram, two main elements can be distinguished:
\begin{packed_item}
	\item Two different sub-networks. On each sub-networks, all Mbeds can share methods or execute a non-local one.
	\item A RPC Websocket server which is responsible to manage all sub-networks and all messages exchanged. This server is written in Python and uses Tornado.
\end{packed_item}


As for the Internet of Things project, each mbed will belong to a specific subnetwork and will be identified by a specific name. This identification is made over the URL used to connect the websocket server:

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\textwidth]{./rpc_ws.jpg}
		\caption{RPC: mbed identification on a subnetwork}
		\label{RPC: mbed identification on a subnetwork}
\end{figure}

Different steps are required to execute a distant method:
\begin{packed_item}
	\item connect several mbeds to the same subnetwork over a websocket communication
	\item then all mbeds can register methods: an mbed has to register on the server one or several methods before than others can call them
	\item an mbed connected over the same subnetwork as the previous mbed can call the registered method
	\item the distant mbed will execute the method and return the results
	\item the local mbed can then handle the result of the distant method
\end{packed_item}

\subsection{Protocol}
The RPC mechanism relies on messages exchanged. On these messages, we need to specify:
\begin{packed_item}
	\item the source of the message
	\item the destination of the message
	\item message name:
		\begin{packed_item}
			\item CALL: to call a distant function
			\item RESULT: this message contains the result of a previous CALL
			\item REGISTER: used to register a specific method to the websocket server
			\item INFO\_METHODS: a client can have access to all methods registered from a specific client
			\item ERROR: an error has been detected
		\end{packed_item}
	\item message ID
\end{packed_item}

These previous fields are common to all messages exchanged. After for each message, other fields can be present:

\begin{packed_item}
	\item CALL:
		\begin{packed_item}
			\item method name: distant method which will be called
			\item params: parameters for this method
		\end{packed_item}
	\item RESULT:
		\begin{packed_item}
			\item result: result of the function called remotely
		\end{packed_item}
	\item REGISTER:
		\begin{packed_item}
			\item fn: on the network, a distant method will be identified by this field
		\end{packed_item}
	\item ERROR:
		\begin{packed_item}
			\item cause: cause of the error:
			\begin{packed_item}
				\item JSON\_PARSE\_ERROR: error in the json format
				\item JSON\_RPC\_ERROR: error in the rpc message format
				\item METHOD\_NOT\_FOUND: the distant method called has not been registered
				\item CLIENT\_NOT\_CONNECTED: the client which must execute the distant method is not connected
			\end{packed_item}
		\end{packed_item}
\end{packed_item}

\subsection{Signature of methods handled}
A user wants to be able to register and then call a function of his choice. So a function can take all kinds of input argument and return whatever type.
As messages are exchanged in JSON format, I decided to use this signature for all methods handled by the RPC mechanism:

\begin{center}
\textbf{ void fn(MbedJSONValue\& in, MbedJSONValue\& out)}
\end{center}

A MbedJSONValue object is the object associated to a string in JSON format. This class can handle parameters such as:
\begin{packed_item}
	\item booleans
	\item integers
	\item doubles
	\item strings
	\item arrays of MbedJSONValue
	\item MbedJSONValue object inside another one
\end{packed_item}

This class has been developed in order to simplifies at maximum the creation of such objects:

\begin{lstlisting}[label=MbedJSONValue manipulation,caption=MbedJSONValue manipulation]
 #include "mbed.h"
 #include "MbedJSONValue.h"
 #include <string>

 int main() {     
    MbedJSONValue demo;

   const  char * json = "{\"my_array\": [\"demo_string\", 10], \"my_boolean\": true}";

   //parse the previous string and fill the object demo
   parse(demo, json);

   std::string my_str;
   int my_int;
   bool my_bool;

   my_str = demo["my_array"][0].get<std::string>();
   my_int = demo["my_array"][1].get<int>();
   my_bool = demo["my_boolean"].get<bool>();
   
    printf("my_str: %s\r\n", my_str.c_str());
    printf("my_int: %d\r\n", my_int);
    printf("my_bool: %s\r\n", my_bool ? "true" : "false");
 }
   \end{lstlisting}

\subsection{Core of the RPC mechanism: MbedJSONRpc}
\subsubsection{Register a method}
To register a method, a user has to invoke:
\begin{lstlisting}[label=MbedJSONValue manipulation,caption=MbedJSONValue manipulation]
template<typename T> RPC_TYPE registerMethod(const char * public_name, T * obj_ptr, void (T::*fn)(MbedJSONValue& val, MbedJSONValue& res))
\end{lstlisting}


This method is responsible to register on the rpc websocket server the specified method:
\begin{packed_item}
	\item Send a websocket message to the server containing a MSG\_REGISTER request:
	\begin{packed_item}
		\item from: mbed\_id
		\item to: gateway
		\item msg: REGISTER
		\item fn: public\_name 
	\end{packed_item}
	\item Wait a response from the server (if the request is successful: REGISTER\_OK)
	\item Fill two local arrays:
	\begin{packed_item}
		\item callback: contains function pointers of methods registered
		\item name: contains identifiers of methods registered
	\end{packed_item}
\end{packed_item}


After this step, a distant mbed will be able to call the method registered identified by "public\_name".
    
\subsubsection{Call a registered method}
To call a distant method, a user has to invoke:
\begin{lstlisting}[label=MbedJSONValue manipulation,caption=MbedJSONValue manipulation]
RPC_TYPE MbedJSONRpc::call(const char * fn, const char * dest, MbedJSONValue& in, MbedJSONValue& out)
\end{lstlisting}

This method, in order to call a distant method, realizes several steps:
\begin{packed_item}
	\item Serialize the in MbedJSONValue object in order to be sent over websockets
	\item Send a websocket message to the server containing a MSG\_CALL request
	\begin{packed_item}
		\item from: mbed\_id
		\item to: dest
		\item msg: CALL
		\item fn: fn
		\item params: "in" serialized
	\end{packed_item}
	\item Wait a MSG\_RESULT message from the server containing the result of the distant method
	\item Fill the "out" reference with the result
\end{packed_item}

After this step, a user can handle the result of the distant method contained in the "out" reference.

\subsubsection{Listen for incoming request}
To listen incoming requests, a user has to invoke:
\begin{lstlisting}[label=MbedJSONValue manipulation,caption=MbedJSONValue manipulation]
void MbedJSONRpc::work()
\end{lstlisting}

This method does the following steps:
\begin{packed_item}
	\item Try to read a websocket message
	\item If a message is available:
		\begin{packed_item}
			\item Check the validity of the message
			\item Convert the "params" field in a MbedJSONValue object
			\item Execute the registered method with the previous in argument. At the same time, the method will fill the "out" parameter containing the result
			\item Serialize the result of the method executed
			\item Send a MSG\_RESULT websocket message to the server;
			\begin{packed_item}
				\item from: mbed\_id
				\item to: msg["from"]
				\item msg: RESULT
				\item res: "out" parameter serialized
			\end{packed_item}
		\end{packed_item}
\end{packed_item}


\subsection{Mbed boards}
\subsubsection{Hardware}
The only requirement for the hardware is to have access to the internet. So a wifi module or an ethernet jack is required.

TODO: photo

\subsubsection{Software: mbed which registers a method}
I will present the main program running on an mbed which has an accelerometer connected. The idea is to remotely access these accelerometers values from another mbed.


\begin{lstlisting}[label=Register a method,caption=Register a method]

// accelerometer
ADXL345 accelerometer(p5, p6, p7, p8);

//wifi module
Wifly wifly(p9, p10, p17, "network", "password", true);

//websocket: configuration with sub-network = sensor and mbed_id = mbed_acc 
Websocket webs("ws://sockets.mbed.org/rpc/sensor/mbed_acc",&wifly);

//RPC object attached to the websocket server
MbedJSONRpc rpc(&webs);

//Acc class. 
class Acc {
public:
    Acc() {};
    void getAcc(MbedJSONValue& in, MbedJSONValue& out) {
        int readings[3] = {0, 0, 0};
        accelerometer.getOutput(readings);
        out[0] = readings[0];
        out[1] = readings[1];
        out[2] = readings[2];
    }
};

//Instance of Acc. The method getAcc of this object will be registered
Acc acc;

int main() {
    
    RPC_TYPE t;
    
    //Accelerometers init
    accelerometer.init();
    
    // join the network
    wifly.join();
    
    //connect the websocket server
    webs.connect();

    //register the acc method and wait for incoming methods
    if((t = rpc.registerMethod("getAcc", &acc, &Acc::getAcc)) == REGISTER_OK) {
        printf("getAcc is registered\r\n");
    		//wait for incoming CALL requests
    		rpc.work(); 
    }
    else {
        printType(t);
    }
    
}
\end{lstlisting}

\subsubsection{Software: mbed which calls a distant method}

\begin{lstlisting}[label=Register a method,caption=Register a method]
//websocket over ethernet: configuration with sub-network = samux and mbed_id = mbed_acc
Websocket webs("ws://sockets.mbed.org/rpc/sensor/mbed_client");

//RPC object attached to the websocket server
MbedJSONRpc rpc(&webs);

int main() {
    RPC_TYPE t;
    
    //in: argument for the distant method (here empty)
    //out results of the distant method (accelerometers values)
    MbedJSONValue in, out;

		// connect the websocket server
    webs.connect();

    //CALL getAcc on mbed_acc
    if ((t = rpc.call("getAcc", "mbed_acc", in, out)) == CALL_OK) {
        printf("acc_x: %d\r\n", out[0].get<int>());
        printf("acc_y: %d\r\n", out[1].get<int>());
        printf("acc_z: %d\r\n", out[2].get<int>());
    } else
        printType(t);
}
\end{lstlisting}

TODO: screenshot of result

\subsection{Websocket server}
The server uses the same framework used for the realtime streaming data project: Tornado. The server is responsible to manage all subnetworks and messages exchanged over a same subnetwork. \\


The main data structure in order to represent the state of the whole network is a dictionnary:
\begin{packed_item}
	\item Each key represents a specific subnetwork
	\item A value associated to a subnetwork is another dictionnary:
		\begin{packed_item}
			\item Each key represents one mbed connected
			\item Each value is a dictionnary containing
			\begin{packed_item}
				\item a reference on the mbed
				\item an array containing methods registered by this mbed
			\end{packed_item}
		\end{packed_item}
\end{packed_item}


\begin{figure}[h!]
		\centering
		\includegraphics[width=0.6\textwidth]{./rpc_server_data_struct.png}
		\caption{Data structure for the RPC websocket server}
		\label{Data structure for the RPC websocket server}
\end{figure}


The websocket server follows the following logic:
\begin{packed_item}
	\item If a new mbed connects a specific subnetwork:
	\begin{packed_item}
		\item Update the dictionnary containing the state of the network by adding an entry on the subnetwork dictionnary
	\end{packed_item}
	
	\item If the server receives a MSG\_REGISTER request:
	\begin{packed_item}
		\item Update the dictionnary containing the state of the network by adding the new distant method in the array associated to the mbed
	\end{packed_item}
	
	\item If the server receives a MSG\_CALL request:
	\begin{packed_item}
		\item Check that the request comes from an mbed on the same subnetwork as the distant mbed
		\item Check that the method called is registered in the array associated to the called mbed
		\item If the two previous steps are sucessful, send a MSG\_CALL message to the distant mbed
	\end{packed_item}
	
	\item If the server receives a MSG\_RESULT message:
	\begin{packed_item}
		\item Check that the mbed which will receive the result of the distant method is on the same subnetwork
		\item Forward the message to the mbed which called the distant method
	\end{packed_item}
	
\end{packed_item}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

\chapter{Universal Serial Bus}

\section{Inside the USB bus}
\subsection{USB overview}
The Universal Serial Bus (USB) is the most widely used bus in today's computer. USB has particularly been designed to standardize connections between the computer and peripherals. For instance, keyboards, printers, scanners, disk drives or cameras can use the same bus to exchange data with a computer. USB has effectively replaced a variety of earlier interfaces, such as serial or parallel ports. The USB bus provides several benefits such as the same interface for many device, the hot pluggable capability which allows a user to connect and disconnect  a USB device whenever he wants or the automatic configuration which is the capacity of the operating system to load a specific driver according to the device connected. Another useful benefit is that the USB interface provides power supply (5V) that can be used by a device if it doesn't require more than 500 mA.\\

USB version 1.0 supported two speeds, a full speed mode of 12Mbits/s and a low speed mode of 1.5Mbits/s. USB 2.0, which is the most widely version of USB, can reach 480Mbits/s. The 480Mbits/s is known as High Speed mode. USB version 3.0 specifies a maximum transmission speed of up to 5Gbits/s (known as SuperSpeed), but few products are supporting USB 3.0 at present.
\\
\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\multirow{2}{*}{USB 1.0} & low-speed & 1.5Mbits/s \\
 & full-speed & 12Mbits/s \\ \hline
USB 2.0 & high-speed & 480Mbits/s \\ \hline
USB 3.0 & super-speed & 5Gbits/s \\ \hline
\end{tabular}
\end{center}
\caption{USB speeds}
\label{USB speeds}
\end{table}

The Universal Serial Bus is host controlled. However, there can only be one host per bus and the host is responsible for undertaking all transactions. Considering this restriction, two devices cannot exchange information without one host. Nevertheless, the On-The-Go specification, which is part of the USB 2.0 standard, has introduced a Host Negotiation Protocol, allowing two devices to negotiate for the role of host. With this specification, we can imagine a camera exchanging data with a printer without the need of a computer. 

\subsection{Topology}
The physical bus topology defines how USB devices are connected to the host. The USB network is implemented as a tiered star network with one host (master) and several devices (slaves). The topology looks like a tree. In order to increase the number of devices connected, a hub need to be connected to the root port. This special hub and the root port are the first tier of the network. Furthermore, the USB network can support up to 127 external nodes but the number of tiers does not exceed 7. The following diagram represents a possible connection architecture on a USB bus.


\begin{figure}[h!]
		\centering
		\includegraphics[width=0.4\textwidth]{./usb_topology.png}
		\caption{USB physical topology \footnotemark}
		\label{USB physical topology}
\end{figure}
\footnotetext{reference: http://www.usblyzer.com}
\subsection{Endpoints and type of transfers}
Devices have a series of buffers to communicate with the host. Each buffer will belong to an endpoint. An endpoint is a uniquely identifiable entity on a USB device, which is the source or terminus of the data that flows from or to the device. For instance, the mbed based on a NXP LPC1768 microcontroller has 32 physical endpoints whereas the mbed based on the NXP LPC11U24, has 10 physical endpoints. One logical endpoint represents two physical endpoints. Each physical endpoints has a specific direction: either OUT to receive data from the host or IN to send data to the host. 

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.8\textwidth]{./endpoint.jpg}
		\caption{Different types of endpoints}
		\label{Different types of endpoints}
\end{figure}

There are four types of endpoints which corresponds to different requirements according to the device: 
\begin{packed_item}
	\item \textbf{Control endpoint}: All USB devices once connected performed an \textit{enumeration step} wherein the host requests all capabilities of the device. Control transfers are used to enumerate a device.
	\item \textbf{Interrupt endpoints}: Interrupts transfers are used when a device requires responsiveness. Typical applications would include keyboard and mouse. Users don't want a noticeable delay between pressing a key or moving a mouse and seeing the result on the screen. An interrupt transfer only occurs when the host polls the device. There is a guarantee that the host will request a data within a specified time interval
	\item \textbf{Bulk endpoints}: Bulk transfers are typically used to transfer large amount of data like files to a printer. A bulk transfer use spare un-allocated bandwidth, so time is not critical with bulk transfers. Typical applications include printers, scanners or mass storage devices.
	\item \textbf{Isochronous endpoints}: Isochronous tranfers are used for streaming and realtime data. For instance, streaming audio and video devices use isochronous transfers. Such devices need a guaranteed delivery rate for data but if an error occurs, the data is not re-transmitted.
\end{packed_item}
	

\subsection{Packets exchanged}
\subsubsection{\underline{Common fields in a USB packet}}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c| >{\centering\arraybackslash}m{9cm} |}
\hline
Field & Length & Meaning \\ \hline
\multirow{2}{*}{SYNC} & low and full speed: 8bits  & \multirow{2}{9cm}{A packet starts with a SYNC pattern to allow the receiver bit clock to synchronise with the data.} \\
\cline{2-2}%
 & high speed: 32bits & \\ \hline
 
EOP &  & A packet ends with an End of Packet (EOP) field \\ \hline

PID & 8bits & Packet ID \\ \hline

\multirow{2}{*}{ADDR} & \multirow{2}{*}{7bits} & The address field specifies which device the packet is designated for\\ \hline

ENDP & 4bits & The endpoint number which the packet is designed for \\ \hline

\multirow{2}{*}{CRC} & \multirow{2}{*}{5 or 16bits} & Cyclic Redundancy Checks are performed on the data within the packet payload \\ \hline
\end{tabular}
\caption{Fields in a USB packet}
\label{Fields in a USB packet}
\end{table}

\subsubsection{\underline{Packets}}
\begin{packed_item}
	\item \textbf{Token Packet}: To indicate the type of transaction to follow, USB uses token packets:
		\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
  	\hline
  		SYNC & PID & ADDR & ENDP & CRC5 & EOP \\ \hline
  		8/32bits & 8bits & 7bits & 4bits & 5bits &  \\
  	\hline
  	\end{tabular}
  	\end{center}
  	
  	There are three types of token packets: 
  	\begin{itemize} \itemsep 0em
			\item IN: The host wants to read information.
			\item OUT: The host wants to send information.
			\item SETUP: Used to begin control transfers.
  	\end{itemize}
  	
  	
	\item \textbf{Data Packet}: Packets which contain the payload
		\begin{center}
		\begin{tabular}{|c|c|c|c|c|}
  	\hline
  		SYNC & PID & DATA & CRC16 & EOP \\ \hline
  		8/32bits & 8bits & (0 - 1024) * 8bits & 16bits &   \\
  	\hline
  	\end{tabular}
  	\end{center}
  	
  	
	\item \textbf{Handshake Packet}: After a data stage, handshake packets are used to acknowledge data or to report errors
		\begin{center}
		\begin{tabular}{|c|c|c|}
  	\hline
  		SYNC & PID & EOP \\ \hline
  		8/32bits & 8bits &  \\
  	\hline
  	\end{tabular}
  	\end{center}
  	
  	There are four types of handshake packets:
  	\begin{itemize} \itemsep 0em
			\item ACK: Packet successfully received.
			\item NAK: The device temporary cannot send or received data
			\item STALL: Endpoint is halted, or control pipe request is not supported.
			\item NYET: No response yet from receiver (high speed only)
  	\end{itemize}
  	
  	
	\item \textbf{Start of Frame Packet}: USB manages time in units called "frames" (USB 2.0 further added "microframes"), and uses frames/microframes to realize the concept of time. Each "frame" represents 1 ms, and each microframe represents 125 microseconds. When performing control, bulk or interrupt transfers with a peripheral device, there is little need to pay attention to the frames/microframes. However, when performing isochronous transfers, frames/microframes may need to be taken into consideration for proper synchronization with the system. For this reason, the host issues SOF (Start Of Frame) packets to the bus to indicate the starting point of each frame/microframe.
	
		\begin{center}
		\begin{tabular}{|c|c|c|c|c|}
  	\hline
  		SYNC & PID & Frame number & CRC5 & EOP \\ \hline
  		8/32bits & 8bits & 11bits & 5bits &   \\
  	\hline
  	\end{tabular}
  	\end{center}
  	
\end{packed_item}


\subsection{Enumeration}
The host hub port is able to detect the attachment of the USB device and makes the host controller aware of the same. The host controller then starts communicating with the USB device (which could be a mouse, keyboard, flash drive etc.). This initial communication between the host and the device is termed as “bus enumeration”. Bus enumeration is the process through which the host learns about the capabilities of the device. Since any USB device can be connected to the host hub port at anytime, bus enumeration becomes the essential first step of USB communication. This step is performed on the control endpoint (endpoint 0). So, all devices must at least have the control endpoint enabled.
During this step, the host will assign a unique address to the device.
All devices capabilities are transmitted in data structures called \textbf{descriptors}. Descriptors are arrays containing some information like the device class, the number of endpoints used, the maximum length of these endpoints,... There are several types of descriptors. Standards descriptors are: device descriptor, configuration descriptor, interface descriptor and endpoint descriptor. But, for each USB class, other descriptors can be found such as the HID (Human Interface Device) descriptor and the report descriptor for HID devices.

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\textwidth]{./descr.jpg}
		\caption{Descriptors}
		\label{Descriptors}
\end{figure}

A typical enumeration follows:
\begin{packed_item}
	\item GET DEVICE DESCRIPTOR: The host sends a get device descriptor request. The device
replies with its device descriptor to report its attributes (Device Class, maximum packet size for endpoint zero).
	\item SET ADDRESS: A USB device uses the default address (0) after reset until the host assigns a unique address using the set address request. The firmware writes the device address assigned by the host.
	\item GET CONFIGURATION DESCRIPTOR: The host sends a get configuration request. The device replies with its configuration descriptor, interface descriptor and endpoint descriptor. The configuration descriptor describes the number of interfaces provided by the configuration, the power source
(Bus or Self powered) and the maximum power consumption of the USB device from the bus.
The Interface descriptor describes the number of endpoints used by this interface. The Endpoint
descriptor describes the transfer type supported and the bandwidth requirements.
	\item SET CONFIGURATION: The host assigns a configuration value to the device based on the
configuration information. The device is now configured and ready to be
used.
\end{packed_item}


\subsection{USB 2.0 transactions}
A transfer consists of 1 or more transactions. Each transaction contains a token packet and may contain a data and/or handshake packet.

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.4\textwidth]{./transfer.png}
		\caption{USB 2.0 transaction}
		\label{USB 2.0 transaction}
\end{figure}

I will illustrate a whole transfer with a control read transfer. This type of transfer is used by the host to request descriptors to a device on the control endpoint:
\begin{packed_item}
	\item Setup transaction:
	\begin{packed_item}
		\item SETUP token packet sent by the host
		\item Data packet: the host sends a request concerning specific descriptor
		\item Handshake packet: the device returns ACK
	\end{packed_item}
	
	\item One or more data transaction(s):
	\begin{packed_item}
		\item IN token packet sent by the host
		\item Data packet: the device sends the descriptor requested
		\item Handshake packet sent by the host
	\end{packed_item}
	
	
	\item Status transaction:
	\begin{packed_item}
		\item OUT token packet sent by the host
		\item Data packet: 0 length data
		\item Handshake packet: the device returns the status
	\end{packed_item}
	
\end{packed_item}


Concerning bulk or interrupts endpoints, a whole OUT transfer can be:
\begin{packed_item}
	\item OUT transaction:
	\begin{packed_item}
		\item OUT token packet sent by the host
		\item Data packet: the host sends data
		\item Handshake packet: the device returns the status (ACK, NAK or STALL)
	\end{packed_item}
\end{packed_item}

Isochronous transfers are the same as bulk or interrupt transfers without the handshake packet. Occasional errors must be acceptable on isochronous transfers.



\newpage
\section{USB Device stack}
A USB device stack has been developped to allow mbed users to design their own USB device or to use their mbed as USB peripheral such as a keyboard or a mouse. USB defines class code information that is used to identify a device’s functionality. This class code is parsed by the USB host stack to load an appropriate device driver. Several classes has been implemented:
\begin{packed_item}
	\item HID (Human Interface Device)
	\item MSD (Mass Storage Device)
	\item Audio
	\item MIDI
	\item a subset of CDC (Communication Device Class) to provide a virtual serial port
\end{packed_item}

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\textwidth]{./usb_capa1.png}
		\caption{USB device stack capabilities}
		\label{USB device stack capabilities}
\end{figure}


\subsection{USB Device stack architecture}
\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\textwidth]{./usb_arch3.png}
		\caption{USB device stack architecture}
		\label{USB device stack architecture}
\end{figure}

\begin{packed_item}

	\item USBHAL: The USB hardware layer for the LPC11U24 and for the LPC1768. In this class, all low level methods are defined. There are USBHAL\_LPC11U24.cpp and USBHAL\_LPC1768.cpp which define functions defined in USBHAL.h. The right .cpp file is chosen according to a macro defined by the compiler: if a user is compiling a program for the LPC1768, the macro TARGET\_LPC1768 is defined. If a user wants to compile a program for the LPC11U24, the macro TARGET\_LPC11U24 is defined. Virtual functions are called on specific events to be treated by subclasses.
	
	\item USBDevice: This layer is in charge to abstract the hardware. At this level, no differences are made between the LPC11U24 and the LPC1768 concerning the target. USBDevice is in charge to perform the setup packet treatment (enumeration step is performed in this class) and provide an abstraction to handle the USB interface.
	
	\item USB class layer:
		\begin{packed_item}
			\item USBHID: implements standard requests of the HID class specification. When a USBHID object is instanciated, the mbed is enumerated as a generic HID device so that raw data can be sent and receive to and from a custom program running on the host side.
			\item USBCDC: implements a subset of the CDC class specification to allow the mbed to be recognized as a virtual serial port
			\item USBMIDI: enables the mbed to send and receive MIDI message to and from a computer
			\item USBAudio: implements standard requests of the USB Audio class. The mbed is enumerated as a microphone and a speaker on the same device.
			\item USBMSD: implements the mass storage specification. This class is generic: a subclass has to implement some pure virtual functions defined in USBMSD to access a storage chip.
		\end{packed_item}
		
	\item USB device layer:
		\begin{packed_item}
			\item USBMouse: used to emulate a mouse
			\item USBKeyboard: used to emulate a keyboard.
			\item USBMouseKeyboard: used to emulate a mouse and a keyboard at the same time
			\item USBSerial: used to emulate a virtual serial port. 
			\item USBMSD\_??: All users can implement their own class which inherits from USBMSD in order to access their storage chip.
		\end{packed_item}
	
	\begin{comment}
	Methods such as init, connect, disconnect, addEndpoint, readEndpoint, writeEndpoint can be found in this class. It's also in this class that the enumeration step is performed for requests concerning standard descriptors. When a packet is received on the control endpoint (endpoint 0 OUT), it is decoded to analyze the request and a response to the host is sent. Descriptors are accessible via virtual functions such as getDeviceDescriptor which returns a pointer on the descriptor. As these functions are virtual, all child classes will be able to use their own descriptors.
	
		\item USBHID, USBCDC and USBMSD: As explained before, these classes represent a specific USB class. A part of the enumeration step can be done here if the host requests a class specific descriptor. These three classes are explained in the next section of this document.
		\item USB\_MOUSE, USB\_KEYBOARD, USB\_MOUSE\_KEYBOARD, USB\_RAW\_HID and \\ USB\_SERIAL: High level libraries to emulate a specific peripheral according to their class. For instance, a keyboard is emulated over the HID class. Methods such as printf, putc are accessible for a keyboard. The USB\_RAW\_HID class is used to send and receive raw data. This can be a good opportunity to design a USB device. USB\_SERIAL is a virtual serial port.
		
		\end{comment}
\end{packed_item}


\subsection{USBHAL: USB Hardware abstraction layer for the LPC11U24}

\begin{center}
\textbf{Source code of main methods are in Annexe A: USBHAL class}
\end{center}


This section describes the hardware layer implemented for the mbed LPC11U24. This microcontroller has a built-in USB 2.0 device controller. It also has 2kbytes of RAM dedicated for USB operations.

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.9\textwidth]{./usb_endpoints.jpg}
		\caption{USB endpoints status array}
		\label{USB endpoints status array}
\end{figure}

To describe the state of each endpoints available, we need to allocate space in USB RAM as specified in the previous figure. Main fields of endpoints status array are:
\begin{packed_item}
	\item A: the endpoint is active or not
	\item NBytes: For OUT endpoints this is the number of bytes that can be received in this buffer. For IN endpoints this is the number of bytes that must be transmitted.
	\item Address offset: represents the end of the address where will be stored data. The beginning of the address is specified in DATABUFSTART register 
\end{packed_item}



Main methods for USBHAL class:
\begin{packed_item}
	\item Memory  allocation for endpoints status list and endpoint 0 buffers. These initializations are done in the constructor of USBHAL::USBHAL.
	\item To add more endpoints, space allocation has to be done. This is done in the method: USBHAL::realiseEndpoint
	\item To read a specific endpoint:
		\begin{packed_item}
			\item Fill the endpoint status list (active bit, address offset and NBytes). After this step, the endpoint is ready to receive data. This is done in USBHAL::endpointRead
			\item When a data is received on the specific endpoint, an interrupt is raised. Software can read data in the buffer of this OUT endpoint. This is done in USBHAL::endpointReadResult.
		\end{packed_item}
	\item To write on a specific endpoint:
		\begin{packed_item}
			\item Fill the endpoint status list (active bit, address offset and NBytes). Copy data in the buffer of the IN endpoint. After this step, the endpoint is ready to send data. This is done in USBHAL::endpointWrite
			\item Wait until the writing has been effectively done. This is done in USBHAL::endpoint-\\WriteResult.
		\end{packed_item}
\end{packed_item}


When a specific event occurs, USBHAL calls virtual functions which can be overrided in a subclass to perform a custom treatment. Main callback functions are:
\begin{packed_item}
	\item SOF(int frameNumber): called on each start of frame event (each 1ms)
	\item EP0setupCallback(): called when a setup packet is received
	\item EPx\_OUT\_callback(): called a data has been received on a specific endpoint
	\item EPx\_IN\_callback(): called when a data has been sent on a specific endpoint
\end{packed_item}


\subsection{USBDevice: target abstraction and setup packet treatment}
\subsubsection{Target abstraction}
One of the purpose of this class is to provide an API in order to handle the USB interface very easily:
\begin{packed_item}
	\item init() to initialize the USB controller
	\item connect() to connect a device
	\item disconnect() to disconnect a device
	\item addEndpoint(int endpoint) to add a specific endpoint
	\item readEP(int endpoint) to read a specific endpoint
	\item writeEP(int endpoint) to write a specific endpoint 
\end{packed_item}

\subsubsection{Setup packet treatment}
Two data structures has been defined in order to perform the control endpoint treatment. The enumeration step is part of this treatment:
\begin{packed_item}
	\item SETUP\_PACKET: to describe a setup packet
	\item CONTROL\_TRANSFER: to describe a transfer on the control endpoint
\end{packed_item}


\begin{lstlisting}[label=Data structures for control endpoint treatment,caption=Data structures for control endpoint treatment]
typedef struct {
    struct {
        uint8_t dataTransferDirection;
        uint8_t Type;
        uint8_t Recipient;
    } bmRequestType;
    uint8_t  bRequest;
    uint16_t wValue;
    uint16_t wIndex;
    uint16_t wLength;
} SETUP_PACKET;

typedef struct {
    SETUP_PACKET setup;
    uint8_t * ptr;      // pointer on a buffer to be sent
    uint32_t remaining; // remaining bytes on the transfer
    uint8_t direction;  // direction: host > device or device > host
    bool zlp;           // zero length packet
    bool notify;
} CONTROL_TRANSFER;
\end{lstlisting}

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.9\textwidth]{./setup_packets.png}
		\caption{Setup packets treatment}
		\label{Setup packets treatment}
\end{figure}

For instance, a GET\_DEVICE\_DESCRIPTOR request is processed following this scheme:
\begin{packed_item}
	\item Reception of a setup packet
	\item Decoding the setup in the SETUP\_PACKET structure
	\item This is not a class specific request so the treatment is done in USBDevice class
	\item The request is GET\_DEVICE\_DESCRIPTOR:
	\begin{packed_item}
		\item Fill the CONTROL\_TRANSFER structure containing in particular a pointer to the device descriptor
		\item This request needs DATA IN stages (the device needs to send the descriptor)
		\item Send data until CONTROL\_TRANSFER.remaining == 0
		\item Read the control endpoint for the status transaction
	\end{packed_item}
\end{packed_item}


A basic device descriptor is quite common to all USB devices. Importants fields are:
\begin{packed_item}	
	\item bcdUSB which is the USB specification release number
	\item bDeviceClass specifies the device class
	\item bMaxPacketSize0 specifies the maximum packet size for endpoint 0
\end{packed_item}

\begin{lstlisting}[label=Device Descriptor,caption=Device Descriptor]
uint8_t * USBDevice::deviceDesc() {
    static uint8_t deviceDescriptor[] = {
        DEVICE_DESCRIPTOR_LENGTH,       // bLength 
        DEVICE_DESCRIPTOR,              // bDescriptorType 
        LSB(USB_VERSION_2_0),           // bcdUSB (LSB) 
        MSB(USB_VERSION_2_0),           // bcdUSB (MSB) 
        0x00,                           // bDeviceClass 
        0x00,                           // bDeviceSubClass 
        0x00,                           // bDeviceprotocol 
        MAX_PACKET_SIZE_EP0,            // bMaxPacketSize0 
        LSB(VENDOR_ID),                 // idVendor (LSB) 
        MSB(VENDOR_ID),                 // idVendor (MSB) 
        LSB(PRODUCT_ID),                // idProduct (LSB) 
        MSB(PRODUCT_ID),                // idProduct (MSB) 
        LSB(PRODUCT_RELEASE),           // bcdDevice (LSB) 
        MSB(PRODUCT_RELEASE),           // bcdDevice (MSB) 
        STRING_OFFSET_IMANUFACTURER,    // iManufacturer 
        STRING_OFFSET_IPRODUCT,         // iProduct 
        STRING_OFFSET_ISERIAL,          // iSerialNumber 
        0x01                            // bNumConfigurations 
    };
    return deviceDescriptor;
}
\end{lstlisting}

\subsection{USBHID class}
\subsubsection{Introduction}
HID is one of the most frequently used USB classes. The HID class was primarily defined for devices that are used by humans to control the operation of computer systems. Typical examples of HID devices include keyboards, mice, trackballs, and joysticks. HID devices may have knobs, switches, buttons, sliders, etc. The HID class is also frequently used for devices that may not require human interaction but provide data in a similar format as HID class devices. Since all operating systems have a built-in HID driver, it's easy to design a USB HID device which doesn't require any specific driver.

Data exchanged between host and device resides in structure called reports. The report format is flexible and can handle any format of data, but each report has a fixed size. This size is specified in a HID descriptor which is transmitted as part of the configuration descriptor.
HID devices are required to provide a Report Descriptor which enumerates all data fields of a report. A HID device can have at most one interrupt IN endpoint and one interrupt OUT endpoint (and the control endpoint to perform the enumeration step).

For each field in the report, the Report Descriptor defines how many bits the field consumes, how often this data is repeated, and which is the type of the data field. Thus, report descriptors are specific to a device.
\\

\begin{lstlisting}[label=HID Configuration Descriptor,caption=HID Configuration Descriptor]
uint8_t * USBHID::configurationDesc() {
    static uint8_t configurationDescriptor[] = {
        CONFIGURATION_DESCRIPTOR_LENGTH,// bLength
        CONFIGURATION_DESCRIPTOR,       // bDescriptorType
        LSB(TOTAL_DESCRIPTOR_LENGTH),   // wTotalLength (LSB)
        MSB(TOTAL_DESCRIPTOR_LENGTH),   // wTotalLength (MSB)
        0x01,                           // bNumInterfaces
        DEFAULT_CONFIGURATION,          // bConfigurationValue
        0x00,                           // iConfiguration
        C_RESERVED | C_SELF_POWERED,    // bmAttributes
        C_POWER(0),                     // bMaxPower

        //Interface descriptor
        INTERFACE_DESCRIPTOR_LENGTH,    // bLength
        INTERFACE_DESCRIPTOR,           // bDescriptorType
        0x00,                           // bInterfaceNumber
        0x00,                           // bAlternateSetting
        0x02,                           // bNumEndpoints
        HID_CLASS,                      // bInterfaceClass
        HID_SUBCLASS_NONE,              // bInterfaceSubClass
        HID_PROTOCOL_NONE,              // bInterfaceProtocol
        0x00,                           // iInterface

        //hid descriptor
        HID_DESCRIPTOR_LENGTH,          // bLength
        HID_DESCRIPTOR,                 // bDescriptorType
        LSB(HID_VERSION_1_11),          // bcdHID (LSB)
        MSB(HID_VERSION_1_11),          // bcdHID (MSB)
        0x00,                           // bCountryCode
        0x01,                           // bNumDescriptors
        REPORT_DESCRIPTOR,              // bDescriptorType
        LSB(reportDescLength()),  			// wDescriptorLength (LSB)
        MSB(reportDescLength()),  			// wDescriptorLength (MSB)

        //endpoint descriptor (interrupt IN endpoint)
        ENDPOINT_DESCRIPTOR_LENGTH,     // bLength
        ENDPOINT_DESCRIPTOR,            // bDescriptorType
        PHY_TO_DESC(EPINT_IN),          // bEndpointAddress
        E_INTERRUPT,                    // bmAttributes
        LSB(MAX_PACKET_SIZE_EPINT),     // wMaxPacketSize (LSB)
        MSB(MAX_PACKET_SIZE_EPINT),     // wMaxPacketSize (MSB)
        1,                              // bInterval (milliseconds)

        //endpoint descriptor (interrupt OUT endpoint)
        ENDPOINT_DESCRIPTOR_LENGTH,     // bLength
        ENDPOINT_DESCRIPTOR,            // bDescriptorType
        PHY_TO_DESC(EPINT_OUT),         // bEndpointAddress
        E_INTERRUPT,                    // bmAttributes
        LSB(MAX_PACKET_SIZE_EPINT),     // wMaxPacketSize (LSB)
        MSB(MAX_PACKET_SIZE_EPINT),     // wMaxPacketSize (MSB)
        1,                              // bInterval (milliseconds)
    };
    return configurationDescriptor;
}
\end{lstlisting}

In the configuration descriptor, we find particularly the interface descriptor which defines the class used by this device (HID\_CLASS) and the number of endpoints that will be used (2). The HID descriptor gives information on the length of the report descriptor. There are finally endpoint descriptors. The communication uses two interrupt endpoints: one IN to send data to the host and one OUT to receive data from the host. Interrupts endpoint are polled by the host, that is why there is a bInterval field in endpoint descriptors.
\\


\subsubsection{HID: Class specific requests}
The HID specification defines several class specific requests. All these requests are processed in the USBCallback\_request() virtual method. The main specific requests are:
\begin{packed_item}
	\item GET\_REPORT: allows the host to receive a report via the Control pipe. This request is useful at initialization time for absolute items and for 
determining the state of feature items.
	\item SET\_REPORT: allows the host to send a report to the device, possibly setting the state of input, output, or feature controls. 
	\item GET\_DESCRIPTOR: to request the HID descriptor or the report descriptor
\end{packed_item}

\subsubsection{Generic HID device}
If a USBHID is instantiated, the device created is a generic HID device. This means that it is not a specific device such as a mouse or a keyboard but a device which can send and receive raw data. The report descriptor for this device is:
 
\begin{lstlisting}[label=Generic HID Report Descriptor,caption=Generic HID Report Descriptor]
uint8_t * USBHID::reportDesc() {
    static uint8_t reportDescriptor[] = {
        0x06, LSB(0xFFAB), MSB(0xFFAB),
        0x0A, LSB(0x0200), MSB(0x0200),
        0xA1, 0x01,         // Collection 0x01
        
        //data are sent in packets containing input_length bytes
        0x75, 0x08,         // report size = 8 bits
        0x15, 0x00,         // logical minimum = 0
        0x26, 0xFF, 0x00,   // logical maximum = 255
        0x95, input_length, // report count
        0x09, 0x01,         // usage
        0x81, 0x02,         // Input (array)
        
        //data are received in packets containing output_length bytes
        0x95, output_length,// report count
        0x09, 0x02,         // usage
        0x91, 0x02,         // Output (array)
        
        0xC0                // end collection

    };
    return reportDescriptor;
}
\end{lstlisting}

There are two main parts:
\begin{packed_item}
	\item Bytes are sent to the host by packets of length \textit{input\_length}
	\item Bytes are received by packets of length \textit{output\_length}
\end{packed_item}


Additionnally, this class defines methods to send and receive reports:

\begin{lstlisting}[label=Send and receive HID reports,caption=Send and receive HID reports]
bool USBHID::send(HID_REPORT *report)
{
    return USBDevice::writeEP(EPINT_IN, report->data, report->length, MAX_HID_REPORT_SIZE);
}


bool USBHID::read(HID_REPORT *report)
{
    uint16_t bytesRead = 0;
    bool result;
    result = USBDevice::readEP(EPINT_OUT, report->data, &bytesRead, MAX_HID_REPORT_SIZE);
    if(!readStart(EPINT_OUT, MAX_HID_REPORT_SIZE))
        return false;
    report->length = bytesRead;
    return result;
}
\end{lstlisting}

\subsubsection{USBMOUSE}
USBMOUSE class is a subclass of USBHID. The important descriptor of this class is the report descriptor which defines data structures which will be exchanged.


\begin{lstlisting}[label=Mouse Report Descriptor,caption=Mouse Report Descriptor]
uint8_t * USBMouse::reportDesc() {
    static uint8_t reportDescriptor[] = {
        USAGE_PAGE(1),      0x01,       // Generic Desktop
        USAGE(1),           0x02,       // Mouse
        COLLECTION(1),      0x01,       // Application
        USAGE(1),           0x01,       // Pointer
        COLLECTION(1),      0x00,       // Physical

        // Buttons
        REPORT_COUNT(1),    0x03,       // 3 buttons
        REPORT_SIZE(1),     0x01,       // 1 bit for each button
        USAGE_PAGE(1),      0x09,       // Buttons
        USAGE_MINIMUM(1),   0x1,    
        USAGE_MAXIMUM(1),   0x3,
        LOGICAL_MINIMUM(1), 0x00,       // Button not pressed
        LOGICAL_MAXIMUM(1), 0x01,       // Button pressed
        INPUT(1),           0x02,       // Input, absolute data
        REPORT_COUNT(1),    0x01,       // Padding to fill 1 byte (5 + 3)
        REPORT_SIZE(1),     0x05,
        INPUT(1),           0x01,
        
        // X, Y and scroll
        REPORT_COUNT(1),    0x03,       // 3 features: X, Y, scroll
        REPORT_SIZE(1),     0x08,       // 1 byte for X, 1 byte for Y and 1 byte for scroll
        USAGE_PAGE(1),      0x01,
        USAGE(1),           0x30,       // X
        USAGE(1),           0x31,       // Y
        USAGE(1),           0x38,       // scroll
        LOGICAL_MINIMUM(1), 0x81,       // Minimum: -127
        LOGICAL_MAXIMUM(1), 0x7f,       // Maximum: 127
        INPUT(1),           0x06,       // Input, Relative data

        END_COLLECTION(0),
        END_COLLECTION(0),
    };
    return reportDescriptor;
}
\end{lstlisting}

On this report descriptor, we can distinguish three different parts:
\begin{packed_item}
	\item At the beginning, there is the indication that a mouse report descriptor will be described.
	\item Buttons mouse: There are 3 buttons represented by 1 bit. Values for these buttons are 0 or 1 (pressed or not). They are input values which means that the device will send information to the host.
	\item X, Y and scroll: 3 different features, each represented by 1 byte. Values can vary between -127 and 127. There are also input values.
\end{packed_item}

The main method to send a mouse state to the host is:

\begin{lstlisting}[label=Mouse Report Descriptor,caption=Mouse Report Descriptor]
bool USBMouse::mouseSend(int8_t x, int8_t y, uint8_t buttons, int8_t z) {
    HID_REPORT report;
    report.data[0] = buttons & 0x07;
    report.data[1] = x;
    report.data[2] = y;
    report.data[3] = -z; // >0 to scroll down, <0 to scroll up

    report.length = 4;

    return USBHID::send(&report);
}
\end{lstlisting}

Concerning USBKeyboard and USBMouseKeyboard classes, the important part is the definition of the report descriptor which defines the format of data sent to the host. 



\subsection{CDC class to emulate a virtual serial port}
\subsubsection{Introduction}
The Communication Device Class (CDC) is a general-purpose way to enable all
types of communications on the Universal Serial Bus. This class makes it possible
to connect telecommunication devices such as digital telephones or analog
modems, as well as networking devices like ADSL or Cable modems.
While a CDC device enables the implementation of quite complex devices, it can also
be used as a very simple solution for communication on the USB. For example, a CDC
device can appear as a virtual COM port, which greatly simplifies application programming
on the host side. For mbed a subset of the CDC class has been implemented in order to create
a virtual serial port over USB.

\subsubsection{Descriptors}
Concerning the device descriptor, bDeviceClass has to be 02h to specify a CDC device.\\


Two interfaces are used in the configuration descriptor:
\begin{packed_item}
	\item \textbf{Communication Class Interface}: used to request and manage the device state. This interface is also used by the host to request capabilities and parameters of the communication. To provide information about the communication, four descriptors are used:
	\begin{packed_item}
		\item CDCHeaderDescriptor: marks the beginning of the concatenated set of functional descriptors for the interface.
		\item CDCCallManagementDescriptor: describes the processing of calls for the Communication Class interface
 		\item CDCAbstractControlManagementDescriptor: describes the commands supported by the Communication Class interface. This device supports for instance the request GET\_LINE\_CODING which allows the host to know parameters of the communication (number of stop bits, parity, number of data bits)
		\item CDCUnionDescriptor: describes the relationship between a group of interfaces that can be considered to form
a functional unit. Here, the master interface is the Communication Class Interface and the slave one is the data Class Interface.
	\end{packed_item}
	\item \textbf{Data Class Interface}: this interface is used for data transfers. For the communication, either bulk or interrupt endpoints are required. For a serial port,  reliability
of the transmission is very important and the data transfers are not time-critical. That is why, two bulk endpoints (one IN and one OUT) are used.
\end{packed_item}


\subsubsection{CDC: Class specific requests}
The CDC specification defines several class specific requests. All these requests are processed in the USBCallback\_request() virtual method. The main specific requests are:
\begin{packed_item}
	\item GET\_LINE\_CODING: allows the host to know parameters of the communication (number of stop bits, parity, number of data bits)
	\item SET\_LINE\_CODING: allows the host to specify typical line-character formatting properties
\end{packed_item}

\subsubsection{USBSerial class}
Once the device enumerated, data can be exchanged over the two bulk endpoints. To send a character, we just write the character on the bulk IN endpoint. Characters received are pushed on a circular buffer called buf. This step is done in the EPx\_OUT\_callback() virtual function called when a packet is received. We can then define two methods to send and receive data:

\begin{lstlisting}[label=USBSerial: putc and getc,caption=USBSerial: putc and getc]
int USBSerial::_putc(int c) {
		writeEP(EPBULK_IN, uint8_t *)&c, 1, MAX_CDC_REPORT_SIZE)
    return 1;
}

int USBSerial::_getc() {
    uint8_t c;
    while (buf.isEmpty());
    buf.dequeue(&c);
    return c;
}

bool USBSerial::EP2_OUT_callback() {
    uint8_t c[65];
    uint16_t size = 0;

    //we read the packet received and put it on the circular buffer
    readEP(EPBULK_OUT, c, size, MAX_CDC_REPORT_SIZE)
    for (int i = 0; i < size; i++) {
        buf.queue(c[i]);
    }

    //call a potential handler
    rx.call();

    // We reactivate the endpoint to receive next characters
    readStart(EPBULK_OUT, MAX_PACKET_SIZE_EPBULK);
    return true;
}
\end{lstlisting}




\subsection{MSD class}
\subsubsection{Introduction}
The Mass Storage Device (MSD) class is an extension to the USB specification that defines
how mass storage devices, such as a hard-disk, SD card, flash chip should operate on the USB.
Many devices use the MSD class to symplify data transfer. More common devices which use this class are hard-drives, USB-stick, MP3 or video player.

\subsubsection{MSD descriptors}
The MSD configuration descriptor defines one interface with bInterfaceClass = 08h specifying the mass storage class. Two bulk endpoints are then defined to transfer data. Bulk endpoints are used because big amount of data can be transferred.

\subsubsection{MSD class specific requests}
The MSD specification defines several class specific requests. All these requests are processed in the USBCallback\_request() virtual method. The main specific requests are:
\begin{packed_item}
	\item RESET: used to reset the device by the host
	\item GET\_MAX\_LUN: allows the host to determine the maximum Logical Unit Number (LUN) supported by the device. This is not equivalent to the number of logical unit on the device, since units are numbered starting from 0. In the mbed library, only 1 logical unit is supported.
\end{packed_item}

\subsubsection{MSD transaction}
The communication between the device and the host is divided into three steps:
\begin{packed_item}
	\item Command stage
	\item An optional data stage
	\item Status stage
\end{packed_item}

The \textbf{command stage} is used by the host to transmit instructions to be performed by the device. These instructions are contained in a Command Block Wrapper (CBW) sent by the host. The CBW describes several parameters of the transaction:

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c| >{\arraybackslash}m{9cm} |}
\hline

Offset & Field & Length (bytes) & Meaning \\ \hline
0 & dCBWSignature & 4 & Signature to identify a valid CBW (0x43425355) \\ \hline
4 & dCBWTag & 4 &  id of the CBW. The device have to answer in the status stage by sending a Command Status Wrapper (CSW) containing the same id. \\ \hline
8 & dCBWTransferLength & 4 & Length of transfer \\ \hline
12 & bmCBWFlags & 1 & bit7: transfer direction (0: OUT, 1: IN) \\ \hline
13 & bCBWLUN & 1 & \textbf{Bits 0-3}: logical unit to which the command is sent \\ \hline
14 & bCBWCBLength & 1 & \textbf{Bits 0-5}: Length of command block in bytes \\ \hline
15 & CBWCB & 0-16 & Command block: instructions to be executed by the device \\ \hline

\end{tabular}
\caption{Command Block Wrapper (CBW)}
\label{Command Block Wrapper (CBW)}
\end{table}

When a CBW has been received and decoded by the device, an optional \textbf{data stage} may take
place if the command requires it. During this step, data flow from or to the device (for instance, if the host wants to read the content of an SD card, there will be a data IN stage). Several transfers can occur successively.
\\

Once the data stage performed, the device must send a Command Status Wrapper (CSW) in response to the CBW. A CSW is used to return the result of a command.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c| >{\arraybackslash}m{9cm} |}
\hline

Offset & Field & Length (bytes) & Meaning \\ \hline
0 & dCSWSignature & 4 & Signature to identify a valid CSW (0x53425355) \\ \hline
4 & dCSWTag & 4 &  Same id as in the CBW \\ \hline
8 & dCSWDataResidue & 4 & Difference between expected and real transfer length \\ \hline
12 & bCSWStatus & 1 & Indicates the result (success or failure) of the command. \\ \hline

\end{tabular}
\caption{Command Status Wrapper (CSW)}
\label{Command Status Wrapper (CSW)}
\end{table}

\subsubsection{MSD State machine}
To implement the three previous step of a transaction, a state machine is used.
This state machine contains 5 states:
\begin{packed_item}
	\item WAIT\_CBW: waiting for the reception of a valid CBW. If a non valid CBW is received, send a CSW reporting an error.
	\item PROCESS\_CBW: decode and execute command from the CBW. If there is a processing error, go into the ERROR state
	\item SEND\_CSW: a CSW is sent
	\item WAIT\_CSW: waiting for CSW reception by the host
	\item ERROR: to report an error.
\end{packed_item}

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.3\textwidth]{./msd_state_machine.png}
		\caption{MSD state machine}
		\label{MSD state machine}
\end{figure}


\subsubsection{SCSI commands}
All commands sent by the host contained in the CBW are part of the SCSI command architecture. In the SCSI protocol, the initiator sends a SCSI command to the target which then responds. SCSI commands are sent in a block, which consists of a one byte operation code followed by five or more bytes containing command-specific parameters. Upon receiving and processing the CBW the target will return a status code byte.\\


Main commands that have to be processed by the device are:
\begin{packed_item}
	\item SCSI\_INQUIRY: The host usually issues an Inquiry command right after the enumeration phase to get more
information about the device.

	\item SCSI\_READ\_CAPACITY: The Read Capacity command enables the host to retrieve the number of block present on a
media, as well as their size.

	\item SCSI\_READ (6)/(10): This command is used by the host to read data from the device.
	
	\item SCSI\_REQUEST\_SENSE: If there is an error the execution of a command, the host will issue a
Request Sense to get more information about the problem. 

	\item SCSI\_TEST\_UNIT\_READY: This command provides a way to check if a logical unit is ready. If the logical unit is not ready, the device reports an error in the CSW. Then the host sends a SCSI\_REQUEST\_SENSE to have more information about the error
\end{packed_item}

The main method to decode a CBW and a SCSI command is:
\begin{lstlisting}[label=MSD CBW decoding,caption=MSD CBW decoding]
void USBMSD::CBWDecode(uint8_t * buf, uint16_t size) {
    if (size == sizeof(cbw)) {
        memcpy((uint8_t *)&cbw, buf, size);
        if (cbw.Signature == CBW_Signature) {
            csw.Tag = cbw.Tag;
            csw.DataResidue = cbw.DataLength;
            if ((cbw.CBLength <  1) || (cbw.CBLength > 16) ) {
                fail();
            } else {
                switch (cbw.CB[0]) {
                    case TEST_UNIT_READY:
                        testUnitReady();
                        break;
                    case REQUEST_SENSE:
                        requestSense();
                        break;
                    case INQUIRY:
                        inquiryRequest();
                        break;
                    case MODE_SENSE6:
                        modeSense6();
                        break;
                    case READ_FORMAT_CAPACITIES:
                        readFormatCapacity();
                        break;
                    case READ_CAPACITY:
                        readCapacity();
                        break;
                    case READ10:
                    case READ12:
                        if (infoTransfer()) {
                            if ((cbw.Flags & 0x80)) {
                                stage = PROCESS_CBW;
                                memoryRead();
                            } else {
                                stallEndpoint(EPBULK_OUT);
                                csw.Status = CSW_ERROR;
                                sendCSW();
                            }
                        }
                        break;
                    case WRITE10:
                    case WRITE12:
                        if (infoTransfer()) {
                            if (!(cbw.Flags & 0x80)) {
                                stage = PROCESS_CBW;
                            } else {
                                stallEndpoint(EPBULK_IN);
                                csw.Status = CSW_ERROR;
                                sendCSW();
                            }
                        }
                        break;
                    case VERIFY10:
                        if (!(cbw.CB[1] & 0x02)) {
                            csw.Status = CSW_PASSED;
                            sendCSW();
                            break;
                        }
                        if (infoTransfer()) {
                            if (!(cbw.Flags & 0x80)) {
                                stage = PROCESS_CBW;
                                memOK = true;
                            } else {
                                stallEndpoint(EPBULK_IN);
                                csw.Status = CSW_ERROR;
                                sendCSW();
                            }
                        }
                        break;
                    default:
                        fail();
                        break;
                }
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Use of USBMSD with a specific storage chip}
The USBMSD class implements the MSD protocol as defined previously. But this class doesn't work standalone, a subclass is needed to define pure virtual functions called in USBMSD in order to access a specific storage chip.\\


Six pure virtual functions have to be defined:
\begin{packed_item}
	\item virtual int disk\_read(char * data, int block): function to read a block
	\item virtual int disk\_write(const char * data, int block): function to write a block
	\item virtual int disk\_initialize(): function to initialize the memory
	\item virtual int disk\_sectors(): return the number of blocks
	\item virtual int disk\_size(): return the memory size
	\item virtual int disk\_status(): return the status of the storage chip (0: OK, 1: not initialized, 2: no medium in the drive, 4: write protection)
\end{packed_item}


\subsection{Audio class}
\subsubsection{Introduction}
The audio class enables a USB device to send and receive encoded voice or music for instance. In the mbed library, a USB audio device has been developed in order to provide a speaker and a microphone in the same device. Devices in the audio class use isochronous transfers for audio streams. The general idea for the device developed is to receive an audio packet each Start of Frame (SOF) generated each 1ms. This device is synchronous. Asynchronous audio devices can be developed using an external clock for instance.

\subsubsection{Descriptors}
Three interfaces are defined in the configuration descriptor:
\begin{packed_item}
	\item Audio Control Interface: describe the functionnal behavior of the device including input terminal, output terminal or features unit. 
	\begin{packed_item}
		\item An Input Terminal is used to interface between outside the device and other Units inside the device. 
		\item An Output Terminal is used to interface between Units inside the audio function and outside the device. 
		\item A feature Unit provides audio control concerning volume or mute for instance.
	\end{packed_item}
	
	\item Audio Streaming Interface: used to interchange digital audio data streams between the Host and the audio device. In our case, two audio streaming interfaces are defined:
	\begin{packed_item}
		\item to receive an audio stream over an isochronous OUT endpoint
		\item to send a stream over an isochronous IN endpoint
	\end{packed_item}
	This interface specifies the type of data exchanged, the number of channels used, the number of bits used to encode a sample or the frequency. In the mbed library, a PCM representation on 16 bits is used to send and receive audio packets. Other parameters can be chosen by a user.
\end{packed_item}

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.8\textwidth]{./audio_archi.png}
		\caption{Audio device interfaces}
		\label{Audio device interfaces}
\end{figure}

\subsubsection{Audio class specific requests}
The Audio specification defines several class specific requests. All these requests are processed in the USBCallback\_request() virtual method. Specific requests have been implemented:
\begin{packed_item}
	\item GET\_CUR: allows the host to know the current volume or the mute state
	\item SET\_CUR: allows the host to set the current volume or the mute state
	\item GET\_MIN: allows the host to know the minimum volume level
	\item GET\_MAX: allows the host to know the maximum volume level
	\item GET\_RES: allows the host to know the resolution attribute between two volume levels
\end{packed_item}

\subsubsection{Reception and sending audio packets}
As explained before, one audio packet is sent or receive on a Start Of Frame event (each ms). So let's say that a frequency of 48 kHz has been chosen with 2 channels (stereo). Knowing that each sample of a packet is 16 bits long, 48 * 2 bytes will be received or sent each millisecond for one channel. In total, for 2 channels, 48 * 2 * 2 bytes will be received. The audio length packet received or sent each millisecond can be compute:
\begin{center}
	AUDIO\_LENGTH\_PACKET = (FREQ / 500) * nb\_channel
\end{center}

According to the number of channels, audio packets have to be interpreted differently:

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\textwidth]{./pcm.png}
		\caption{PCM packet: mono}
		\label{PCM packet: mono}
\end{figure}

\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\textwidth]{./pcm_stereo.png}
		\caption{PCM packet: stereo}
		\label{PCM packet: stereo}
\end{figure}


The main part of sending and reception of audio packets is in the virtual function called in USBHAL on each start of frame events:
\begin{lstlisting}[label=Manage audio packets in SOF events,caption=Manage audio packets in SOF events]
// Called in ISR context on each start of frame
void USBAudio::SOF(int frameNumber) {

    uint16_t size = 0;
    
    // read the isochronous endpoint if the user has provided a buffer
    if (buf_stream_in != NULL) {
       if (USBDevice::readEP_NB(EP3OUT, (uint8_t *)buf_stream_in, &size, PACKET_SIZE_ISO_IN)) {
           // if an audio packet is available, notify
           if (size) {
               available = true;
               readStart(EP3OUT, PACKET_SIZE_ISO_IN);
               buf_stream_in = NULL;
           }
       }
    }
    
    // write if needed
    if (buf_stream_out != NULL) {
       USBDevice::writeNB(EP3IN, (uint8_t *)buf_stream_out, PACKET_SIZE_ISO_OUT, PACKET_SIZE_ISO_OUT);
       buf_stream_out = NULL;
    }

    SOF_handler = true;
}
\end{lstlisting}



\chapter{References}
http://www.bbc.co.uk/news/technology-13613536







\appendix
\chapter*{USBHAL class}

\begin{lstlisting}[label=USBHAL::USBHAL(),caption=USBHAL::USBHAL()]
USBHAL::USBHAL(void) {
    NVIC_DisableIRQ(USB_IRQn);

    // nUSB_CONNECT output
    LPC_IOCON->PIO0_6 = 0x00000001;

    // Enable clocks (USB registers, USB RAM)
    LPC_SYSCON->SYSAHBCLKCTRL |= CLK_USB | CLK_USBRAM;

    // Ensure device disconnected (DCON not set)
    LPC_USB->DEVCMDSTAT = 0;

    // to ensure that the USB host sees the device as
    // disconnected if the target CPU is reset.
    wait(0.3);

    // Reserve space in USB RAM for endpoint command/status list
    // Must be 256 byte aligned
    usbRamPtr = ROUND_UP_TO_MULTIPLE(usbRamPtr, 256);
    ep = (EP_COMMAND_STATUS *)usbRamPtr;
    usbRamPtr += (sizeof(EP_COMMAND_STATUS) * NUMBER_OF_LOGICAL_ENDPOINTS);
    LPC_USB->EPLISTSTART = (uint32_t)(ep) & 0xffffff00;

    // Reserve space in USB RAM for Endpoint 0
    // Must be 64 byte aligned
    usbRamPtr = ROUND_UP_TO_MULTIPLE(usbRamPtr, 64);
    ct = (CONTROL_TRANSFER *)usbRamPtr;
    usbRamPtr += sizeof(CONTROL_TRANSFER);
    LPC_USB->DATABUFSTART =(uint32_t)(ct) & 0xffc00000;

    // Setup command/status list for EP0
    ep[0].out[0] = 0;
    ep[0].in[0] =  0;
    ep[0].out[1] = CMDSTS_ADDRESS_OFFSET((uint32_t)ct->setup);

    // Route all interrupts to IRQ, some can be routed to
    // USB_FIQ if you wish.
    LPC_USB->INTROUTING = 0;

    // Set device address 0, enable USB device, no remote wakeup
    devCmdStat = DEV_ADDR(0) | DEV_EN | DSUS;
    LPC_USB->DEVCMDSTAT = devCmdStat;

    // Enable interrupts for device events and EP0
    LPC_USB->INTEN = DEV_INT | EP(EP0IN) | EP(EP0OUT);
    instance = this;
    
    //attach IRQ handler and enable interrupts
    NVIC_SetVector(USB_IRQn, (uint32_t)&_usbisr);
    NVIC_EnableIRQ(USB_IRQn);
}
\end{lstlisting}

\begin{lstlisting}[label=USBHAL::realiseEndpoint(),caption=USBHAL::realiseEndpoint()]
bool USBHAL::realiseEndpoint(uint8_t endpoint, uint32_t maxPacket, uint32_t options) {
    uint32_t tmpEpRamPtr;

    if (endpoint > LAST_PHYSICAL_ENDPOINT) {
        return false;
    }

    // Not applicable to the control endpoints
    if ((endpoint==EP0IN) || (endpoint==EP0OUT)) {
        return false;
    }

    // Allocate buffers in USB RAM
    tmpEpRamPtr = epRamPtr;

    // Must be 64 byte aligned
    tmpEpRamPtr = ROUND_UP_TO_MULTIPLE(tmpEpRamPtr, 64);

    if ((tmpEpRamPtr + maxPacket) > (USB_RAM_START + USB_RAM_SIZE)) {
        // Out of memory
        return false;
    }

    // Allocate first buffer
    endpointState[endpoint].buffer[0] = tmpEpRamPtr;
    tmpEpRamPtr += maxPacket;

    if (!(options & SINGLE_BUFFERED)) {
        // Must be 64 byte aligned
        tmpEpRamPtr = ROUND_UP_TO_MULTIPLE(tmpEpRamPtr, 64);

        if ((tmpEpRamPtr + maxPacket) > (USB_RAM_START + USB_RAM_SIZE)) {
            // Out of memory
            return false;
        }

        // Allocate second buffer
        endpointState[endpoint].buffer[1] = tmpEpRamPtr;
        tmpEpRamPtr += maxPacket;
    }

    // Commit to this USB RAM allocation
    epRamPtr = tmpEpRamPtr;

    // Remaining endpoint state values
    endpointState[endpoint].maxPacket = maxPacket;
    endpointState[endpoint].options = options;

    // Enable double buffering if required
    if (options & SINGLE_BUFFERED) {
        LPC_USB->EPBUFCFG &= ~EP(endpoint);
    } else {
        // Double buffered
        LPC_USB->EPBUFCFG |= EP(endpoint);
    }

    // Enable interrupt
    LPC_USB->INTEN |= EP(endpoint);

    // Enable endpoint
    unstallEndpoint(endpoint);
    return true;
} 
\end{lstlisting}

\begin{lstlisting}[label=USBHAL::endpointReadResult(),caption=USBHAL::endpointReadResult()]
EP_STATUS USBHAL::endpointReadResult(uint8_t endpoint, uint8_t *data, uint32_t *bytesRead) {

    uint8_t bf = 0;
    
    if (!(epComplete & EP(endpoint)))
        return EP_PENDING;
    else {
        epComplete &= ~EP(endpoint);

        //check which buffer has been filled
        if (LPC_USB->EPBUFCFG & EP(endpoint)) {
            // Double buffered (here we read the previous buffer which was used)
            if (LPC_USB->EPINUSE & EP(endpoint)) {
                bf = 0;
            } else {
                bf = 1;
            }
        }

        // Find how many bytes were read
        *bytesRead = (uint32_t) (endpointState[endpoint].maxPacket - BYTES_REMAINING(ep[PHY_TO_LOG(endpoint)].out[bf]));

        // Copy data
        USBMemCopy(data, ct->out, *bytesRead);
        return EP_COMPLETED;
    }
}
\end{lstlisting}

\begin{lstlisting}[label=USBHAL::endpointWrite(),caption=USBHAL::endpointWrite()]
EP_STATUS USBHAL::endpointWrite(uint8_t endpoint, uint8_t *data, uint32_t size) {
    uint32_t flags = 0;
    uint32_t bf;

    // Validate parameters
    if (data == NULL) {
        return EP_INVALID;
    }

    if (endpoint > LAST_PHYSICAL_ENDPOINT) {
        return EP_INVALID;
    }

    if ((endpoint==EP0IN) || (endpoint==EP0OUT)) {
        return EP_INVALID;
    }

    if (size > endpointState[endpoint].maxPacket) {
        return EP_INVALID;
    }

    if (LPC_USB->EPBUFCFG & EP(endpoint)) {
        // Double buffered
        if (LPC_USB->EPINUSE & EP(endpoint)) {
            bf = 1;
        } else {
            bf = 0;
        }
    } else {
        // Single buffered
        bf = 0;
    }

    // Check if already active
    if (ep[PHY_TO_LOG(endpoint)].in[bf] & CMDSTS_A) {
        return EP_INVALID;
    }

    // Check if stalled
    if (ep[PHY_TO_LOG(endpoint)].in[bf] & CMDSTS_S) {
        return EP_STALLED;
    }

    // Copy data to USB RAM
    USBMemCopy((uint8_t *)endpointState[endpoint].buffer[bf], data, size);

    // Add options
    if (endpointState[endpoint].options & RATE_FEEDBACK_MODE) {
        flags |= CMDSTS_RF;
    }

    if (endpointState[endpoint].options & ISOCHRONOUS) {
        flags |= CMDSTS_T;
    }

    // Add transfer
    ep[PHY_TO_LOG(endpoint)].in[bf] = CMDSTS_ADDRESS_OFFSET( \
                                      endpointState[endpoint].buffer[bf]) \
                                      | CMDSTS_NBYTES(size) | CMDSTS_A | flags;

    return EP_PENDING;
}
\end{lstlisting}







\end{document}